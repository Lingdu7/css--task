<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>简述JS中this的指向</title>

	<link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

	<!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
	<link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

	<!-- syntax highlighting 代码高亮主题 -->
	<link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

	<link rel="icon" href="favicon.ico" type="x-icon">

	<style>
		.float {
			float: left;
		}

		a {
			color: #fff !important;
		}

		.dsp-b {
			display: block;
			height: 520px;
			overflow-y: auto;
		}

		.ll p {
			text-align: left !important;
		}

		.txt-l {
			text-align: left !important;
		}

		h4 {
			text-transform: capitalize !important;
		}

		p {
			font-size: 24px !important
		}
	</style>


	<!-- 打印和PDF输出样式 -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : './css/reveal/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<img src="./葡萄藤PPT_files/logo.png" alt="" usemap="#pttmap" class="base-logo">
	<map name="pttmap">
		<area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com/" alt="" target="_blank">
	</map>
	<div class="reveal default center" role="application" data-transition-speed="slow"
		data-background-transition="fade">
		<div class="slides"
			style="width: 960px; height: 700px; left: 50%; top: 50%; bottom: auto; right: auto; transform: translate(-50%, -50%) scale(0.756);">
			<section class="past" style="top: 158px; display: none;" hidden="" aria-hidden="true">
				<h3>简述JS中this的指向</h3>
				<p>分享人：姚富成</p>
			</section>
			<section class="past" style="top: 3px; display: block;" hidden="" aria-hidden="true">
				<p>目录</p>
				<a href="#beijing">
					<p>1.背景介绍</p>
				</a>
				<a href="#zhishi">
					<p>2.知识剖析</p>
				</a>
				<a href="#changjian">
					<p>3.常见问题</p>
				</a>
				<p>4.解决方案</p>
				<p>5.编码实战</p>
				<a href="#kuozhan">
					<p>6.扩展思考</p>
				</a>
				<a href="#cankao">
					<p>7.参考文献</p>
				</a>
				<a href="#gengduo">
					<p>8.更多讨论</p>
				</a>
			</section>
			<section id="beijing" class="past" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3>1.背景介绍</h3>
			</section>
			<section class="past" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<p>js 的 this 是个比较令人头疼的东西，尤其是在面试的时候，深受面试官的喜爱。我们今天来谈谈 js 中的 this</p>
			</section>
			<section class="past" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3>this是什么</h3>
				<p class="txt-l dsp-b">理解this之前， 先纠正一个观点，this
					既不指向函数自身，也不指函数的词法作用域。如果仅通过this的英文解释，太容易产生误导了。它实际是在函数被调用时才发生的绑定，也就是说this具体指向什么，取决于你是怎么调用的函数。</p>
			</section>
			<section class="past" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3>为什么要用this</h3>
				<p class="txt-l dsp-b">this机制提供了更优雅的方式来隐含地“传递”一个对象引用，导致更加干净的 API 设计和更容易的复用。当我们的代码和使用环境约复杂，我们就越能感受到 this
					的重要性</p>
			</section>
			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3 id="zhishi">2.知识剖析</h3>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>this 绑定规则</h4>
				<p>this的4种绑定规则分别是：默认绑定、隐式绑定、显示绑定、new 绑定。优先级从低到高。</p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>默认绑定</h4>
				<p>什么叫默认绑定，即没有其他绑定规则存在时的默认规则。这也是函数调用中最常用的规则。</p>
				<pre>

	function foo(){
		var a = 1 ;
	console.log(this.a);    // 10
	}
	var a = 10;
	foo();

            </pre>
				<p>这种就是典型的默认绑定，我们看看foo调用的位置，”光杆司令“，像 这种直接使用而不带任何修饰的函数调用 ，就 默认且只能 应用 默认绑定。</p>
				<p><strong>注意：默认绑定一般是绑定window上，严格模式下 是undefined。</strong></p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>隐式绑定</h4>
				<p>除了直接对函数进行调用外，有些情况是，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。</p>
				<pre>

	function foo(){
		console.log(this.a);
	}
	var obj = {
		a : 10,
		foo : foo
	}
	foo();     // undefined
						
	obj.foo();  // 10

            </pre>
				<p>foo()的这个写法就是我们刚刚写的默认绑定,等价于打印window.a,故输出undefined ,。</p>
				<p>下面obj.foo()这种大家应该经常写，这其实就是我们要讨论的 隐性绑定 。</p>
				<p>函数foo执行的时候有了上下文对象，即 obj。这种情况下，函数里的this默认绑定为上下文对象，等价于打印obj.a,故输出10 。<br>
					如果是链性的关系，比如 xx.yy.obj.foo();, 上下文取函数的直接上级，即紧挨着的那个，或者说对象链的最后一个。</p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>隐式丢失（函数别名）</h4>
				<p>这里存在一个陷阱，大家在分析调用过程时，要特别小心</p>
				<pre>

	function foo() { 
		onsole.log( this.a );
	}
						
	var a = 2;
						
	var obj = { 
		a: 3,
		foo: foo 
	};
						
	var bar = obj.foo;
		bar(); //2

			</pre>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<p>为什么bar() 打印的结果是2，obj.foo 赋值给bar，那调用bar()为什么没有触发隐式绑定，使用的是默认绑定呢</p>
				<p>这里有个概念要理解清楚，obj.foo 是引用属性，赋值给bar的实际上就是foo函数（即：bar指向foo本身）。</p>
				<p>那么，实际的调用关系是：通过bar找到foo函数，进行调用。整个调用过程并没有obj的参数，所以是默认绑定，全局属性a。</p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>隐式丢失（回调函数）</h4>
				<pre>

	function foo() { 
		console.log( this.a );
	}
						
	var a = 2;
						
	var obj = { 
		a: 3,
		foo: foo 
	};
						
	setTimeout( obj.foo, 100 ); // 2
            </pre>
				<p>同样的道理，虽然参传是obj.foo，因为是引用关系，所以传参实际上传的就是foo对象本身的引用。对于setTimeout的调用，还是 setTimeout -> 获取参数中foo的引用参数 -> 执行
					foo 函数，中间没有obj的参与。这里依旧进行的是默认绑定。</p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>显性绑定</h4>
				<p>隐性绑定的限制</p>
				<p>在我们刚刚的 隐性绑定中有一个致命的限制，就是上下文必须包含我们的函数 ，例：var obj = { foo : foo
					},如果上下文不包含我们的函数用隐性绑定明显是要出错的，不可能每个对象都要加这个函数 ,那样的话扩展,维护性太差了，我们接下来聊的就是直接 给函数强制性绑定this。</p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>显性绑定</h4>
				<p>call apply bind</p>
				<p>这里我们就要用到 js 给我们提供的函数 call 和 apply，它们的作用都是改变函数的this指向，第一个参数都是 设置this对象。</p>

				<pre>
	function foo(a,b){
		console.log(a+b);
	}
	foo.call(null,'海洋','饼干');     // 海洋饼干  这里this指向不重要就写null了
	foo.apply(null, ['海洋','饼干'] );     // 海洋饼干
			</pre>
				<p>两个函数的区别：</p>
				<p>call从第二个参数开始所有的参数都是 原函数的参数。</p>
				<p> apply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。</p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>显性绑定</h4>
				<p>bind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回。例:</p>
				<pre>

	function foo(){
		console.log(this.a);
	}
	var obj = { a : 10 };
							
	foo = foo.bind(obj);
	foo();   //10

				</pre>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>显性绑定</h4>
				<pre>

	function foo(){
		console.log(this.a);
	}
	ar obj = {
		a : 10            //去掉里面的foo
	}
	foo.call(obj);        // 10 
	
					</pre>

				<p>将隐性绑定例子中的 上下文对象 里的函数去掉了，显然现在不能用 上下文.函数
					这种形式来调用函数，大家看代码里的显性绑定代码foo.call(obj)，看起来很怪，和我们之前所了解的函数调用不一样。<br>其实call 是 foo
					上的一个函数,在改变this指向的同时执行这个函数。</p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>new 绑定</h4>
				<p>创建一个新对象少不了一个概念，那就是构造函数，传统的面向对象 构造函数 是类里的一种特殊函数，要创建对象时使用new 类名()的形式去调用类中的构造函数，而js中就不一样了。</p>
				<p>js中的只要用new修饰的 函数就是'构造函数'，准确来说是 函数的构造调用，因为在js中并不存在所谓的'构造函数'。</p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>new 绑定</h4>
				<p>那么用new 做到函数的构造调用后，js帮我们做了什么工作呢:</p>
				<p>创建一个新对象。<br>
					把这个新对象的__proto__属性指向 原函数的prototype属性。(即继承原函数的原型)<br>
					<strong>将这个新对象绑定到 此函数的this上 。</strong> <br>
					返回新对象，如果这个函数没有返回其他对象。</p>
				<p>第三条就是我们下面要聊的new绑定</p>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>new 绑定</h4>
				<pre>
	function foo(){
		this.a = 10;
		console.log(this);
	}
	foo();       // window对象
	console.log(window.a);    // 10   默认绑定
						
	var obj = new foo();      // foo{ a : 10 }  创建的新对象的默认名为函数名
	// 然后等价于 foo { a : 10 };  var obj = foo;
	console.log(obj.a);       // 10    new绑定
				</pre>
			</section>
			<section class="future ll" style="top: 267px; display: block;" hidden="" aria-hidden="true">
					<h4>new 绑定</h4>
					<p>使用new调用函数后，函数会 以自己的名字 命名 和 创建 一个新的对象，并返回。</p>
					<p>特别注意 : 如果原函数返回一个对象类型，那么将无法返回新对象,你将丢失绑定this的新对象</p>
					<pre>

	unction foo(){
		this.a = 10;
		return new String("捣蛋鬼");
	}
	var obj = new foo();
	console.log(obj.a);       // undefined
	console.log(obj);         // "捣蛋鬼"

					</pre>
				</section>
			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3 id="changjian">3.常见问题</h3>
			</section>
		


			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3>4.解决方案</h3>
			</section>
			

			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3>5.编码实战</h3>
			</section>

			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3 id="kuozhan">6.扩展思考</h3>
			</section>

			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
					<h4>this绑定优先级</h4>
					<p>new 绑定 > 显示绑定 > 隐式绑定 > 默认绑定</p>
			</section>
			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3 id="cankao">7.参考文献</h3>
			</section>
			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4 style="text-transform: lowercase !important" id="cankao">
						https://segmentfault.com/a/1190000011194676</h4>
			</section>
			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h3 id="gengduo">8.更多讨论</h3>
			</section>
			
			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>总结</h4>
				<p>如果函数被new 修饰</p>
				<p>this绑定的是新创建的对象，例:var bar = new foo(); 函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar , 这样的绑定方式叫 new绑定 .</p><br>
				<p>如果函数是使用call,apply,bind来调用的</p>
				<p >this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj , 这样的绑定方式叫 显性绑定 .</p><br>
			</section>
			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
					<h4>总结</h4>
					<p>如果函数是在某个 上下文对象 下被调用</p>
					<p>this绑定的是那个上下文对象，例 : var obj = { foo : foo }; obj.foo(); foo 中的 this 就是 obj . 这样的绑定方式叫 隐性绑定 .</p><br>
					<p>如果都不是，即使用默认绑定</p>
					<p > 例:function foo(){...} foo() ,foo 中的 this 就是 window.(严格模式下默认绑定到undefined).这样的绑定方式叫 默认绑定 ..</p><br>
				</section>
			<section class="future" style="top: 267px; display: block;" hidden="" aria-hidden="true">
				<h4>鸣谢</h4>
				<p>感谢大家观看</p>
				<small>by: 姚富成</small>
			</section>

		</div>
		<div class="backgrounds">
			<div class="slide-background past" data-loaded="true" style="display: none;"></div>
			<div class="slide-background past" data-loaded="true" style="display: block;"></div>
			<div class="slide-background past" data-loaded="true" style="display: block;"></div>
			<div class="slide-background stack present" data-loaded="true" style="display: block;">
				<div class="slide-background past" data-loaded="true" style="display: block;"></div>
				<div class="slide-background present" data-loaded="true" style="display: block;"></div>
			</div>
			<div class="slide-background future" data-loaded="true" style="display: block;"></div>
			<div class="slide-background future" data-loaded="true" style="display: block;"></div>
			<div class="slide-background future" data-loaded="true" style="display: none;"></div>
			<div class="slide-background future" data-loaded="true" style="display: none;"></div>
			<div class="slide-background future" style="display: none;"></div>
			<div class="slide-background stack future" style="display: none;">
				<div class="slide-background present" style="display: none;"></div>
			</div>
			<div class="slide-background future" style="display: none;"></div>
			<div class="slide-background stack future" style="display: none;">
				<div class="slide-background present" style="display: none;"></div>
			</div>
			<div class="slide-background future" style="display: none;"></div>
			<div class="slide-background stack future" style="display: none;">
				<div class="slide-background present" style="display: none;"></div>
			</div>
			<div class="slide-background stack future" style="display: none;">
				<div class="slide-background present" style="display: none;"></div>
				<div class="slide-background future" style="display: none;"></div>
				<div class="slide-background future" style="display: none;"></div>
			</div>
			<div class="slide-background future" style="display: none;"></div>
			<div class="slide-background future" style="display: none;"></div>
			<div class="slide-background future" style="display: none;"></div>
			<div class="slide-background future" style="display: none;"></div>
		</div>
		<div class="progress" style="display: block;"><span style="width: 260.19px;"></span></div>
		<aside class="controls" style="display: block;"><button class="navigate-left enabled"
				aria-label="previous slide"></button><button class="navigate-right enabled"
				aria-label="next slide"></button><button class="navigate-up enabled"
				aria-label="above slide"></button><button class="navigate-down" aria-label="below slide"></button>
		</aside>
		<div class="slide-number" style="display: none;"></div>
		<div class="speaker-notes" data-prevent-swipe=""></div>
		<div class="pause-overlay"></div>
		<div id="aria-status-div" aria-live="polite" aria-atomic="true"
			style="position: absolute; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px);">


		</div>
	</div>

	<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
	<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

	<script>

		// 以下为常见配置属性的默认值
		// {
		//  controls: true, // 是否在右下角展示控制条
		//  progress: true, // 是否显示演示的进度条
		//  slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
		//  history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
		//  keyboard: true, // 是否启用键盘快捷键来导航
		//  overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
		//  center: true, // 是否将幻灯片垂直居中
		//  touch: true, // 是否在触屏设备上启用触摸滑动切换
		//  loop: false, // 是否循环演示
		//  rtl: false, // 是否将演示的方向变成RTL，即从右往左
		//  fragments: true, // 全局开启和关闭碎片。
		//  autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
		//  transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
		//  transitionSpeed: 'default', // 过渡速度，default/fast/slow
		//  mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
		// }

		// 初始化幻灯片
		Reveal.initialize({
			//        history: true,
			transition: 'default',
			transitionSpeed: 'slow',
			dependencies: [
				{ src: '../plugin/markdown/marked.js' },
				{ src: '../plugin/markdown/markdown.js' },
				{ src: '../plugin/notes/notes.js', async: true },
				{
					src: '../plugin/highlight/highlight.js', async: true, callback: function () {
						hljs.initHighlightingOnLoad();
					}
				}
			]
		});
		//    原始类型对象直接赋值不会相互影响
		//    var a = 1;
		//
		//    var b = a;
		//    b = 10;
		//    console.log(a); // 1
		////
		//    var a = 'hello';
		//    var b = a;
		//    b = 'world';
		//    console.log(a); // hello
		//
		//    var a = true;
		//    var b = a;
		//    b = false;
		//    console.log(a);

		//数组浅复制
		//    var a = ['隔壁老王','冠希哥', '宋经理' //定义一个名为a的属猪，里面有3个值，
		//    ];
		//    var b = a;   //定义一个变量b，把a赋值给他，这样比、b和a一样了
		//    b[2] = '冲冲老师'; //然后把b的第三个值等于冲冲老师
		//    console.log(a)//那么现在打印a 是什么结果呢
		//
		//    var arr = ["One","Two","Three"];   //数组的深复制，slice方法
		//    var arrtoo = arr.slice(1);
		//    arrtoo[2] = "set Map";
		//    console.log(arr);//One,Two,Three
		//    console.log(arrtoo);//One,set Map,Three

		//
		//    var arr1 = ["One","Two","Three"]; //数组的深复制，concat 方法
		//    var arrtooo = arr1.concat(111111);
		//    arrtooo[1] = "set Map To";
		//    console.log(arr1);//One,Two,Three
		//    console.log(arrtooo);//One,set Map To,Three

		//
		//    var b=[1,2,3,4,5];   //concat的链接
		//    var c=[6,7,8,9];
		//    var d =[4,4,22]
		//    console.log(b.concat(c,d))

		var a = { name: 'yy', age: 26 };  //对象的浅拷贝哦
		var b = new Object();
		b.name = a.name;
		b.age = a.age;
		b.name = 'xx';
		console.log(a);//Object { name="yy", age=26}
		console.log(b);//Object { name="xx", age=26}

		var d = {            //对象的浅拷贝哦 第一种
			name: 'd',
			oc: {
				age: 32
			},
			oad: {
				adds: {
					bb: 12
				}
			}
		};
		var deepCopy = function (source) {
			var result = {};
			for (var key in source) {
				result[key] = typeof source[key] === 'object' ? deepCopy(source[key]) : source[key]
			}
			return result
		};

		var c = deepCopy(d);
		c.name = 'c';
		c.oc = {
			age: 49
		};
		console.log(c);
		console.log(d);


		//    var person = {    //第二种深拷贝
		//        name: 'aa',
		//        friends: ['da', 'dsa', 'gf']
		//    };
		//
		//    var aPerson = Object.create(person, {
		////        name: {
		////            value: "gee"
		////        }
		//    });
		//
		//    console.log(person.name);
		//    console.log(aPerson.friends)

		var Chinese = {
			nation: '中国'

		}
		var Doctor = {
			career: '医生'
		}

		function extendCopy(p) {
			var c = {};
			for (var i in p) {
				c[i] = p[i];
			}
			c.uber = p;
			return c;
		}

		var Doctor = extendCopy(Chinese);
		Doctor.career = '医生';
		console.log(Doctor); // 中国
		Chinese.birthPlaces = ['北京', '上海', '香港'];
		var Doctor = extendCopy(Chinese);
		Doctor.birthPlaces.push('厦门');

	</script>

</body>

</html>